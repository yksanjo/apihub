# Forking and Customization Pathways

## 3. License and Legal Foundation

### 3.1.1 MIT License explicit permissions: "free to do whatever you want with it, even offering as paid service"

The explicit commercial authorization from the project maintainer removes legal ambiguity for business planning. This direct permission, combined with MIT License terms, enables:

- **Direct commercialization**: SaaS offerings, hosted services, paid distributions
- **Competitive use**: BaaS platforms competing with any existing or future PocketBase commercial offerings
- **Proprietary modification**: Closed-source improvements without disclosure obligations
- **Sublicensing**: Custom terms for derivative works, subject to MIT notice preservation

### 3.1.2 No attribution requirements for derivative commercial products

The MIT License's minimal attribution burden—copyright and license notice preservation in copies or substantial portions—enables white-label deployment without prominent branding requirements. Runtime attribution (splash screens, API headers, marketing materials) is unnecessary, supporting clean brand identity establishment for forked products.

### 3.1.3 Clean intellectual property status for corporate adoption

| IP Factor | PocketBase Status | Risk Assessment |
|-----------|-------------------|-----------------|
| Copyright ownership | Single maintainer, clear authorship | Low—no corporate assignment complexity |
| Contributor agreements | None required (standard GitHub ToS) | Low—no CLA negotiation overhead |
| Patent exposure | No known claims, established patterns | Low—backend infrastructure prior art extensive |
| Third-party dependencies | Permissive licenses, minimal tree | Low—no GPL/AGPL contamination |
| Trademark | "PocketBase" unregistered | Low—custom branding recommended regardless |

## 3.2 Extension Mechanisms

### 3.2.1 Custom business logic injection via Go framework integration

PocketBase functions as an importable Go framework for deep customization:

```go
app := pocketbase.New()
app.OnServe().BindFunc(func(se *core.ServeEvent) error {
    se.Router.GET("/api/custom/endpoint", customHandler)
    return se.Next()
})
// ... additional configuration
app.Start()
```

This pattern enables: custom HTTP handlers, middleware injection, scheduled tasks, database migrations, and complete API surface replacement while retaining PocketBase core services.

### 3.2.2 JavaScript hook system for event interception and modification

The pb_hooks directory enables runtime customization without recompilation:

```javascript
// pb_hooks/main.pb.js
onRecordBeforeCreateRequest((e) => {
    // Validation, transformation, external service integration
    const response = $http.send({ url: 'https://api.validator.com/check', ... });
    if (response.statusCode !== 200) {
        e.error("Validation failed", "EXTERNAL_CHECK_FAILED");
    }
}, "orders");
```

Sandboxed execution with controlled API surface ($app, $http, $security, collection DAOs) enables safe third-party extension.

### 3.2.3 Custom route registration for specialized API endpoints

Custom routes integrate with standard middleware chain (authentication, rate limiting, CORS, logging), supporting: complex queries, webhook receivers, batch operations, and third-party integration endpoints.

### 3.2.4 Console command extensions for CLI tooling

Custom CLI commands enable administrative operations, data migration, report generation, and scheduled task execution with full server context access.

## 3.3 Deployment and Operational Flexibility

### 3.3.1 Self-hosted single-server vertical scaling (10,000+ persistent connections)

| Scaling Characteristic | Specification | Implication |
|------------------------|---------------|-------------|
| Concurrent connections | 10,000+ WebSocket | Substantial real-time application capacity |
| Scaling model | Vertical only | Single-node architecture simplicity |
| Recommended use case | Small to midsize applications | Explicit scope boundaries |
| Database size | Single-server storage limited | Planning required for data growth |

Horizontal scaling requires application-level patterns (sharding, read replica distribution) or architectural evolution for workloads exceeding single-node capacity.

### 3.3.2 Container-ready with minimal resource footprint

| Deployment Attribute | Specification |
|----------------------|---------------|
| Typical image size | ~35MB uncompressed, <10MB with UPX compression |
| Minimum memory | 128MB development, 512MB–1GB production |
| Startup time | Sub-second |
| Health check endpoint | Built-in for orchestration integration |

### 3.3.3 Development-to-production parity through single binary model

The identical artifact across environments eliminates "works on my machine" issues: same binary for local development, CI testing, staging, and production, with behavior differences controlled through configuration rather than build variation.
